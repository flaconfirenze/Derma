<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale: 1.0">
    <title>Appcloner Maker</title>
    <style>
        :root {
          --primary-blue: #1a73e8;
          --hover-blue: #1557b0;
          --bg-gray: #f8f9fa;
          --border-gray: #dadce0;
        }

        body {
          font-family: 'Roboto', sans-serif;
          margin: 0;
          padding: 16px;
          background: white;
        }

        .container {
          max-width: 800px;
          margin: 0 auto;
        }

        .category {
          margin-bottom: 24px;
          border: 1px solid var(--border-gray);
          border-radius: 8px;
        }

        .category-header {
          background: var(--primary-blue);
          color: white;
          padding: 12px 16px;
          border-radius: 8px 8px 0 0;
          font-weight: 500;
          cursor: pointer;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }

        .category-content {
          padding: 16px;
          display: none;
        }

        .category-content.active {
          display: block;
        }

        .setting-group {
          margin-bottom: 20px;
          padding: 15px;
          background-color: #f5f5f5;
          border-radius: 8px;
          box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
        }

        .setting-group h3 {
          margin-top: 0;
          margin-bottom: 15px;
          color: var(--primary-blue);
          font-size: 18px;
          font-weight: 500;
        }

        .setting-group .setting {
          margin-left: 15px;
          margin-bottom: 12px;
        }

        .setting {
          margin-bottom: 12px;
        }

        .setting-label {
          display: block;
          margin-bottom: 8px;
          color: #333;
          font-weight: 500;
        }

        .setting select {
          width: 100%;
          padding: 12px;
          border: 1px solid var(--border-gray);
          border-radius: 4px;
          font-size: 14px;
          background: white;
          cursor: pointer;
          appearance: none;
          -webkit-appearance: none;
          background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%231a73e8'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
          background-repeat: no-repeat;
          background-position: right 12px center;
          background-size: 20px;
          transition: border-color 0.2s, box-shadow 0.2s;
        }

        .setting select:hover {
          border-color: var(--primary-blue);
        }

        .setting select:focus {
          outline: none;
          border-color: var(--primary-blue);
          box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
        }

        .setting select option {
          padding: 12px;
          font-size: 14px;
        }

        .setting input[type="text"],
        .setting input[type="number"] {
          width: 100%;
          padding: 8px;
          border: 1px solid var(--border-gray);
          border-radius: 4px;
          font-size: 14px;
          box-sizing: border-box;
        }

        .setting input[type="checkbox"] {
          margin-right: 8px;
        }

        .array-field {
          border-left: 3px solid var(--primary-blue);
          padding: 16px;
          margin: 12px 0;
          background: white;
          border-radius: 0 4px 4px 0;
          box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .array-field .setting-label {
          color: var(--primary-blue);
          font-size: 15px;
          font-weight: 500;
          margin-bottom: 12px;
        }

        .array-field select {
          background-color: var(--bg-gray);
        }

        .array-field:hover {
          border-left-color: var(--hover-blue);
          background-color: var(--bg-gray);
          transition: all 0.2s ease;
        }

        .save-btn {
          position: fixed;
          bottom: 24px;
          right: 24px;
          background: var(--primary-blue);
          color: white;
          padding: 12px 24px;
          border-radius: 24px;
          border: none;
          font-size: 16px;
          font-weight: 500;
          cursor: pointer;
          box-shadow: 0 2px 4px rgba(0,0,0,0.2);
          z-index: 1000;
        }

        .chevron {
          transition: transform 0.3s;
        }

        .chevron.active {
          transform: rotate(180deg);
        }

        #loading {
          display: none;
          text-align: center;
          padding: 20px;
        }

        .error-message {
          color: #d32f2f;
          padding: 10px;
          margin: 10px 0;
          border-radius: 4px;
          background: #ffebee;
          display: none;
        }

        .setting-checkbox {
          position: relative;
          display: flex;
          align-items: center;
          padding: 12px;
          background: var(--bg-gray);
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s ease;
          flex-grow: 1; /* Allow label part to grow */
        }

        .setting-checkbox:hover {
          background: #eef2ff;
        }

        .setting-checkbox input[type="checkbox"] {
          position: absolute;
          opacity: 0;
          cursor: pointer;
          height: 0;
          width: 0;
        }

        .checkmark {
          position: relative;
          height: 24px;
          width: 48px;
          background-color: #ccc;
          border-radius: 12px;
          transition: all 0.3s ease;
          flex-shrink: 0;
        }

        .checkmark:before {
          content: '';
          position: absolute;
          height: 20px;
          width: 20px;
          left: 2px;
          bottom: 2px;
          background-color: white;
          border-radius: 50%;
          transition: all 0.3s ease;
        }

        .setting-checkbox input:checked ~ .checkmark {
          background-color: var(--primary-blue);
        }

        .setting-checkbox input:checked ~ .checkmark:before {
          transform: translateX(24px);
        }

        .setting-checkbox .toggle-label {
          margin-left: 12px;
          font-weight: 500;
          color: #333;
          flex-grow: 1;
        }

        .setting-checkbox .toggle-status {
          margin-left: auto;
          font-size: 14px;
          color: #666;
          white-space: nowrap;
          padding-left: 10px;
        }

        .slider-container {
          display: flex;
          align-items: center;
          gap: 12px;
        }

        .slider-value {
          min-width: 48px;
          padding: 4px 8px;
          background: var(--primary-blue);
          color: white;
          border-radius: 4px;
          text-align: center;
          font-size: 14px;
          white-space: nowrap;
        }

        input[type="range"] {
          flex-grow: 1;
          height: 4px;
          background: var(--border-gray);
          border-radius: 2px;
          appearance: none;
        }
        .array-container {
            margin-bottom: 15px;
        }

        .array-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .array-item input {
            flex-grow: 1;
            margin-right: 10px;
        }

        .object-item {
            flex-wrap: wrap;
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        .object-field {
            display: flex;
            flex-direction: column;
            margin-right: 15px;
            margin-bottom: 5px;
        }

        .object-field label {
            margin-bottom: 2px;
            font-size: 12px;
            color: #666;
        }

        .add-item, .add-complex-item, .remove-item {
            background-color: var(--primary-blue);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }

        .remove-item {
            background-color: #d32f2f;
        }

        .add-item:hover, .add-complex-item:hover, .remove-item:hover {
            opacity: 0.8;
        }
        input[type="range"]::-webkit-slider-thumb {
          appearance: none;
          width: 16px;
          height: 16px;
          background: var(--primary-blue);
          border-radius: 50%;
          cursor: pointer;
          transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
          transform: scale(1.2);
          background: var(--hover-blue);
        }

        /* Hide package info section but keep it in DOM for functionality */
        #package-info {
          display: none;
        }

        .custom-input-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .custom-input-container .custom-input {
            flex-grow: 1;
            margin-top: 0;
            width: auto;
            margin-bottom: 0 !important;
        }

        .generate-btn {
            padding: 8px 12px;
            background-color: var(--primary-blue);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            transition: background-color 0.2s;
            flex-shrink: 0;
        }

        .generate-btn:hover {
            background-color: var(--hover-blue);
        }

        .array-field .custom-input-container input[type="text"] {
            width: auto;
        }

        .directory-list-container {
            margin-bottom: 16px;
            border-left: 4px solid #1a73e8;
            padding-left: 12px;
            background: #f9f9f9;
            border-radius: 0 4px 4px 0;
        }

        .directory-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 12px 0;
        }

        .directory-name {
            font-weight: 500;
            color: #1a73e8;
        }

        .options-count {
            margin-left: 8px;
            color: #666;
            font-size: 14px;
        }

        .dropdown-arrow {
            transition: transform 0.3s;
        }

        .dropdown-arrow.expanded {
            transform: rotate(180deg);
        }

        .directory-list-content {
            padding: 12px 0 12px 16px;
            display: none;
            border-top: 1px solid #eee;
            margin-top: 8px;
        }

        .directory-list-content.active {
            display: block;
        }

        .directory-textarea {
            width: 100%;
            min-height: 100px;
            padding: 8px 12px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            font-size: 14px;
            font-family: monospace;
            resize: vertical;
            margin-bottom: 8px;
            box-sizing: border-box;
        }

        .directory-help-text {
            font-size: 12px;
            color: #666;
            margin-bottom: 12px;
        }

        .directory-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .directory-btn {
            background: none;
            border: none;
            color: #1a73e8;
            font-weight: 500;
            cursor: pointer;
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 4px;
        }

        .directory-btn:hover {
            background-color: rgba(26, 115, 232, 0.1);
        }

        .directory-btn.primary {
            background-color: #1a73e8;
            color: white;
        }

        .directory-btn.primary:hover {
            background-color: #0b5cad;
        }

        /* Modal Styles */
        .modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.6);
          display: none; /* Hidden by default */
          justify-content: center;
          align-items: center;
          z-index: 2000;
        }

        .modal-content {
          background-color: white;
          padding: 25px;
          border-radius: 8px;
          box-shadow: 0 5px 20px rgba(0,0,0,0.25);
          width: 90%;
          max-width: 550px;
          max-height: 85vh;
          display: flex;
          flex-direction: column;
        }

        .modal-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          border-bottom: 1px solid var(--border-gray);
          padding-bottom: 12px;
          margin-bottom: 18px;
        }

        .modal-header h3 {
          margin: 0;
          color: var(--primary-blue);
          font-size: 20px;
          font-weight: 500;
        }

        .modal-close-btn {
          background: none;
          border: none;
          font-size: 28px;
          font-weight: bold;
          color: #aaa;
          cursor: pointer;
          padding: 0 5px;
          line-height: 1;
        }
        .modal-close-btn:hover {
          color: #333;
        }

        .modal-body {
          overflow-y: auto;
          flex-grow: 1;
          padding-right: 10px; /* Space for scrollbar */
        }

        .modal-body .setting {
          margin-bottom: 18px;
        }
        .modal-body .setting-label {
          font-weight: 500;
          margin-bottom: 6px;
          color: #333;
        }
        .modal-body input[type="text"],
        .modal-body input[type="number"],
        .modal-body select {
          width: 100%;
          padding: 10px;
          border: 1px solid var(--border-gray);
          border-radius: 4px;
          font-size: 14px;
          box-sizing: border-box;
        }
        .modal-body .setting-checkbox {
            padding: 10px;
            background-color: var(--bg-gray);
            border-radius: 4px;
        }
        .modal-body .setting-checkbox .toggle-label {
            font-size: 14px; /* Slightly smaller for modal if needed */
        }


        .modal-footer {
          border-top: 1px solid var(--border-gray);
          padding-top: 15px;
          margin-top: 20px;
          display: flex;
          justify-content: flex-end;
          gap: 10px;
        }

        .modal-btn {
          padding: 10px 20px;
          border-radius: 4px;
          border: 1px solid var(--border-gray);
          cursor: pointer;
          font-weight: 500;
          font-size: 14px;
          background-color: white;
        }
        .modal-btn.primary {
          background-color: var(--primary-blue);
          color: white;
          border-color: var(--primary-blue);
        }
        .modal-btn.primary:hover {
          background-color: var(--hover-blue);
        }
        .modal-btn:not(.primary):hover {
          background-color: #f1f1f1;
        }

        .configure-child-btn {
            margin-left: 10px;
            padding: 7px 14px; /* Slightly larger */
            font-size: 13px;
            background-color: #e9ecef; /* Lighter gray */
            border: 1px solid #ced4da;
            color: #495057;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            white-space: nowrap;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .configure-child-btn:hover:not(:disabled) {
            background-color: #dde2e6;
            border-color: #b6bfc8;
        }
        .configure-child-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .parent-toggle-setting { /* This is the .setting div containing the toggle and button */
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        /* Ensure the setting-checkbox (label wrapper) within parent-toggle-setting doesn't take all space */
        .parent-toggle-setting > .setting-checkbox {
            flex-grow: 1; /* Label part takes available space */
            /* margin-right: 10px; /* Optional: space before button */
        }

    </style>
</head>
<body>
<div class="container">
  <div id="package-info" style="display: none;">
    <p>Package Name: <span id="packageNameDisplay">Not detected yet</span></p>
    <p>Split Count: <span id="splitCountDisplay">101 (default)</span></p>
  </div>

  <div id="loading">Loading configuration...</div>
  <div id="error-message" class="error-message"></div>

  <div id="config-container"></div>

  <button class="save-btn" onclick="saveConfig()">Save Settings</button>
</div>

<div id="child-settings-modal" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header">
            <h3 id="modal-title">Configure Details</h3>
            <button type="button" class="modal-close-btn" aria-label="Close">&times;</button>
        </div>
        <div id="modal-body" class="modal-body">
            <!-- Child settings will be dynamically inserted here -->
        </div>
        <div class="modal-footer">
            <button type="button" id="modal-cancel-btn" class="modal-btn">Cancel</button>
            <button type="button" id="modal-apply-btn" class="modal-btn primary">Apply</button>
        </div>
    </div>
</div>

<script>
// Constants for API access
const BIN_ID = '67fe9e1f8960c979a585d694';
const API_KEY = '$2a$10$SgT4qoOKXP6CD4u1jPEpduwi.2NbrCqV2u71AaL7mGaW.77CmNU7u';

const NON_INTERACTIVE_DIRECTORY_KEYS = ['stringsProperties'];

let jsonConfig = {};
let currentPackageName = "";
let configFileSplitCount = 101;
let currentModalContext = { parentKey: null, category: null, parentLabel: null };


document.addEventListener('DOMContentLoaded', loadConfiguration);

async function loadConfiguration() {
    const loading = document.getElementById('loading');
    const errorMessage = document.getElementById('error-message');
    const container = document.getElementById('config-container');
    loading.style.display = 'block';
    errorMessage.style.display = 'none';
    container.innerHTML = '';

    try {
        const response = await fetch(`https://api.jsonbin.io/v3/b/${BIN_ID}/latest`, {
            headers: { 'X-Master-Key': API_KEY }
        });
        if (!response.ok) throw new Error(`Failed to load configuration (Status: ${response.status})`);
        const data = await response.json();
        jsonConfig = data.record;
        renderConfiguration(jsonConfig);
        initializeEventListeners();
    } catch (error) {
        errorMessage.textContent = `Error: ${error.message}`;
        errorMessage.style.display = 'block';
        console.error("Configuration Load Error:", error);
        if (window.Android) window.Android.showToast(`Failed to load config: ${error.message}`);
    } finally {
        loading.style.display = 'none';
    }
}

function generateConfig() { return getUpdatedConfig(); }
function updatePackageName(packageName) {
    currentPackageName = packageName;
    const el = document.getElementById('packageNameDisplay');
    if (el) el.textContent = packageName;
    if (window.Android) window.Android.showToast("Package name updated: " + packageName);
}
function updateSplitCount(count) {
    configFileSplitCount = count;
    const el = document.getElementById('splitCountDisplay');
    if (el) el.textContent = count;
    if (window.Android) window.Android.showToast("Split count updated: " + count);
}

function renderConfiguration(config) {
    const container = document.getElementById('config-container');
    container.innerHTML = '';
    Object.entries(config).forEach(([category, settings]) => {
        const filteredSettings = Object.fromEntries(
            Object.entries(settings).filter(([key]) => !NON_INTERACTIVE_DIRECTORY_KEYS.includes(key))
        );
        if (Object.keys(filteredSettings).length > 0) {
            const categoryElement = createCategorySection(category, filteredSettings);
            container.appendChild(categoryElement);
        }
    });
}

function createCategorySection(category, settings) {
    const section = document.createElement('div');
    section.className = 'category';
    const header = document.createElement('div');
    header.className = 'category-header';
    header.innerHTML = `<span>${formatLabel(category)}</span><span class="chevron">⌵</span>`;
    const content = document.createElement('div');
    content.className = 'category-content';

    let settingKeys = Object.keys(settings);
    for (let i = 0; i < settingKeys.length; i++) {
        const key = settingKeys[i];
        if (isChildSetting(key, settingKeys)) continue;
        const value = settings[key];
        const settingElement = createSettingElement(key, value, category, settings);
        if (settingElement) content.appendChild(settingElement);
    }
    section.appendChild(header);
    section.appendChild(content);
    return section;
}

function isChildSetting(key, allKeysInCategory) {
    for (const parentKey of allKeysInCategory) {
        if (key !== parentKey && key.startsWith(parentKey)) {
            const suffix = key.substring(parentKey.length);
            if (suffix && (suffix[0] === suffix[0].toUpperCase() || !isNaN(parseInt(suffix[0])) || suffix === 'Value')) {
                 return true;
            }
        }
    }
    return false;
}

function createSettingElement(key, value, category, allSettingsInCategory) {
    if (NON_INTERACTIVE_DIRECTORY_KEYS.includes(key) || key === 'fakeWifiNetworks') return null;

    const setting = document.createElement('div');
    const dataPath = `${category}.${key}`;
    const formattedLabel = formatLabel(key);

    if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object' && value[0] !== null) {
        // ... (Array of objects rendering - unchanged)
        setting.className = 'setting-group';
        setting.innerHTML = `<h3>${formattedLabel}</h3>`;
        value.forEach((object, index) => {
            const objectContainer = document.createElement('div');
            objectContainer.className = 'object-item setting';
            objectContainer.innerHTML = `<div class="setting-label" style="margin-bottom: 10px; font-weight: bold;">Item ${index + 1}</div>`;
            Object.entries(object).forEach(([objKey, objValue]) => {
                const fieldDiv = document.createElement('div');
                fieldDiv.className = 'object-field';
                const objDataPath = `${dataPath}[${index}].${objKey}`;
                fieldDiv.innerHTML = `
                    <label for="${key}-${index}-${objKey}">${formatLabel(objKey)}:</label>
                    <input type="text"
                        id="${key}-${index}-${objKey}"
                        value="${objValue || ''}"
                        data-path="${objDataPath}"
                        data-key="${objKey}">
                `;
                objectContainer.appendChild(fieldDiv);
            });
            setting.appendChild(objectContainer);
        });
    } else if (typeof value === 'object' && value !== null && !Array.isArray(value) && Object.keys(value).some(k => !isNaN(parseInt(k)))) {
        // ... (Object with numeric keys as SDK versions - unchanged)
        setting.className = 'setting-group';
        setting.innerHTML = `<h3>${formattedLabel}</h3>`;
        Object.entries(value).forEach(([objKey, objValue]) => {
            if (typeof objValue === 'boolean') {
                const fieldDiv = document.createElement('div');
                fieldDiv.className = 'setting';
                fieldDiv.style.marginLeft = '0';
                const objDataPath = `${dataPath}.${objKey}`;
                fieldDiv.innerHTML = `
                    <label class="setting-checkbox">
                        <input type="checkbox" data-path="${objDataPath}" data-key="${objKey}" ${objValue ? 'checked' : ''}>
                        <span class="checkmark"></span>
                        <span class="toggle-label">SDK Version ${objKey}</span>
                        <span class="toggle-status">${objValue ? 'Enabled' : 'Disabled'}</span>
                    </label>
                `;
                setting.appendChild(fieldDiv);
            }
        });
    } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        // ... (Simple object rendering - unchanged)
        setting.className = 'setting-group';
        setting.innerHTML = `<h3>${formattedLabel}</h3>`;
        Object.entries(value).forEach(([objKey, objValue]) => {
            const fieldDiv = document.createElement('div');
            fieldDiv.className = 'setting';
            fieldDiv.style.marginLeft = '0';
            const objDataPath = `${dataPath}.${objKey}`;
            let inputElement;
            const objLabel = formatLabel(objKey);

            if (typeof objValue === 'boolean') {
                inputElement = `
                    <label class="setting-checkbox">
                        <input type="checkbox" data-path="${objDataPath}" data-key="${objKey}" ${objValue ? 'checked' : ''}>
                        <span class="checkmark"></span>
                        <span class="toggle-label">${objLabel}</span>
                        <span class="toggle-status">${objValue ? 'Enabled' : 'Disabled'}</span>
                    </label>
                `;
                 fieldDiv.innerHTML = inputElement;
            } else {
                if (typeof objValue === 'number') {
                    inputElement = `<input type="number" data-path="${objDataPath}" data-key="${objKey}" value="${objValue}">`;
                } else {
                    inputElement = `<input type="text" data-path="${objDataPath}" data-key="${objKey}" value="${objValue || ''}">`;
                }
                 fieldDiv.innerHTML = `
                    <label class="setting-label">${objLabel}</label>
                    ${inputElement}
                `;
            }
            setting.appendChild(fieldDiv);
        });
    } else if (Array.isArray(value)) {
        // ... (Array of primitives / select rendering - unchanged)
        setting.className = 'array-field setting';
        const isIdentitySetting = key.startsWith('change') &&
            (key.includes('Id') || key.includes('Mac') || key.includes('Imei') ||
             key.includes('Imsi') || key.includes('Serial') || key.includes('Locale') ||
             key.includes('Advertising') || key.includes('Address') || key.includes('Framework'));

        const customInputId = `${category}-${key}-custom-input-${Date.now()}`;
        setting.innerHTML = `
            <label class="setting-label">
                ${formattedLabel}
                <span style="font-size: 12px; color: #666; margin-left: 8px;">
                    (${value.length} options)
                </span>
            </label>
            <select data-path="${dataPath}" data-key="${key}">
                ${value.map(option => `<option value="${option}">${option}</option>`).join('')}
                ${isIdentitySetting ? '<option value="custom">CUSTOM</option>' : ''}
            </select>
            ${isIdentitySetting ?
              `<div class="custom-input-container" style="display:none;">
                  <input type="text" id="${customInputId}" class="setting custom-input" data-path="${dataPath}" data-key="${key}-custom" placeholder="Enter custom value">
                  <button type="button" class="generate-btn" data-target-input="${customInputId}" data-setting-key="${key}">Generate</button>
               </div>` :
              ''}
        `;
    } else if (typeof value === 'boolean') {
        setting.className = 'setting parent-toggle-setting'; // Added class for flex layout
        let hasChildSettings = false;
        for (const childKey in allSettingsInCategory) {
            if (childKey.startsWith(key) && childKey !== key) {
                 const suffix = childKey.substring(key.length);
                 if (suffix && (suffix[0] === suffix[0].toUpperCase() || !isNaN(parseInt(suffix[0])) || suffix === 'Value' )) {
                    hasChildSettings = true;
                    break;
                 }
            }
        }

        setting.innerHTML = `
            <label class="setting-checkbox">
                <input type="checkbox" data-path="${dataPath}" data-key="${key}" ${value ? 'checked' : ''}>
                <span class="checkmark"></span>
                <span class="toggle-label">${formattedLabel}</span>
                <span class="toggle-status">${value ? 'Enabled' : 'Disabled'}</span>
            </label>
            ${hasChildSettings ? `<button type="button" class="configure-child-btn" data-parent-key="${key}" data-category="${category}" data-parent-label="${formattedLabel}" ${!value ? 'disabled' : ''}>Configure</button>` : ''}
        `;
        // Child settings container is no longer rendered here.
    } else if (typeof value === 'number' && (key.includes('Battery') || key.includes('battery') || key.includes('Level'))) {
        // ... (Slider rendering - unchanged)
        setting.className = 'setting';
        let min = 0, max = 100, step = 1, unit = '%';
        if (key.includes('Temp')) { min = -20; max = 80; unit = '°C'; }
        else if (key.includes('Voltage')) { min = 3000; max = 4500; unit = 'mV'; step = 10; }
        setting.innerHTML = `
            <label class="setting-label">${formattedLabel}</label>
            <div class="slider-container">
                <input type="range" data-path="${dataPath}" data-key="${key}" value="${value}" min="${min}" max="${max}" step="${step}">
                <span class="slider-value">${value}${unit}</span>
            </div>
        `;
    } else if (typeof value === 'number') {
        // ... (Number input - unchanged)
        setting.className = 'setting';
        setting.innerHTML = `
            <label class="setting-label">${formattedLabel}</label>
            <input type="number" data-path="${dataPath}" data-key="${key}" value="${value}">
        `;
    } else { // Default: Text Input
        // ... (Text input - unchanged)
        setting.className = 'setting';
        setting.innerHTML = `
            <label class="setting-label">${formattedLabel}</label>
            <input type="text" data-path="${dataPath}" data-key="${key}" value="${value || ''}">
        `;
    }
    return setting;
}

function generateRandomValue(settingKey) {
    // ... (Unchanged)
    const keyLower = settingKey.toLowerCase();
    const hex = () => Math.floor(Math.random() * 16).toString(16);
    const generateUUID = () => `${Array.from({length: 8}, hex).join('')}-${Array.from({length: 4}, hex).join('')}-4${Array.from({length: 3}, hex).join('')}-${['8','9','a','b'][Math.floor(Math.random()*4)]}${Array.from({length: 3}, hex).join('')}-${Array.from({length: 12}, hex).join('')}`;
    const generateAlphaNumUpper = (length) => { let r = ''; const c = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; for (let i = 0; i < length; i++) r += c.charAt(Math.floor(Math.random() * c.length)); return r; };

    if (keyLower.includes('wifimacaddress') || keyLower.includes('bluetoothmacaddress')) return Array.from({ length: 6 }, () => Math.floor(Math.random() * 256).toString(16).padStart(2, '0')).join(':').toUpperCase();
    if (keyLower.includes('imei')) return Array.from({ length: 15 }, () => Math.floor(Math.random() * 10)).join('');
    if (keyLower.includes('androidid')) return Array.from({ length: 16 }, hex).join('');
    if (keyLower.includes('simserialnumber')) return Array.from({ length: Math.floor(Math.random() * 3) + 18 }, () => Math.floor(Math.random() * 10)).join('');
    if (keyLower.includes('advertisingid')) return generateUUID();
    if (keyLower.includes('imsi')) { const mcc = ['310', '311', '208', '234'][Math.floor(Math.random()*4)]; const mnc = ['150', '260', '410', '010', '020', '015', '020'][Math.floor(Math.random()*7)]; const msin = Array.from({ length: 10 }, () => Math.floor(Math.random()*10)).join(''); return mcc + mnc.padStart(3, '0') + msin; }
    if (keyLower.includes('openid')) return generateUUID();
    if (keyLower.includes('googleserviceframeworkid') || keyLower.includes('gsfid')) return Array.from({ length: 16 }, hex).join('');
    if (keyLower.includes('facebookattributionid')) return generateUUID();
    if (keyLower.includes('appsetid')) return generateUUID();
    if (keyLower.includes('hardwareserial') || settingKey === 'changeAndroidSerial') return generateAlphaNumUpper(Math.floor(Math.random() * 7) + 10);
    
    console.warn(`No specific random generator implemented for key: ${settingKey}. Returning placeholder.`);
    return `RANDOM_${settingKey.replace(/([A-Z])/g, '_$1').toUpperCase()}`;
}

function formatLabel(key) {
    if (!key) return '';
    let result = key.replace(/([A-Z])/g, ' $1');
    result = result.charAt(0).toUpperCase() + result.slice(1);
    result = result.replace(/Sdk( |$)/g, 'SDK ').replace(/Id( |$)/g, 'ID ').replace(/Mac( |$)/g, 'MAC ').replace(/Imei( |$)/g, 'IMEI ').replace(/Imsi( |$)/g, 'IMSI ');
    return result.trim();
}

function initializeEventListeners() {
    const container = document.getElementById('config-container');
    if (!container) return;

    container.addEventListener('click', function(event) {
        const categoryHeader = event.target.closest('.category-header');
        if (categoryHeader) {
            const content = categoryHeader.nextElementSibling;
            const chevron = categoryHeader.querySelector('.chevron');
            if (content && chevron) {
                content.classList.toggle('active');
                chevron.classList.toggle('active');
            }
            return;
        }

        if (event.target.classList.contains('generate-btn')) {
            // ... (Unchanged)
            event.preventDefault();
            const button = event.target;
            const targetInputId = button.dataset.targetInput;
            const settingKey = button.dataset.settingKey;
            const targetInput = document.getElementById(targetInputId);
            if (targetInput && settingKey) {
                targetInput.value = generateRandomValue(settingKey) || '';
                targetInput.dispatchEvent(new Event('input', { bubbles: true }));
                targetInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
            return;
        }

        if (event.target.classList.contains('configure-child-btn')) {
            const btn = event.target;
            openChildSettingsModal(btn.dataset.parentKey, btn.dataset.category, btn.dataset.parentLabel);
            return;
        }
    });

    container.addEventListener('change', function(event) {
        if (event.target.type === 'checkbox') {
            const checkbox = event.target;
            const statusElement = checkbox.parentElement.querySelector('.toggle-status');
            if (statusElement) statusElement.textContent = checkbox.checked ? 'Enabled' : 'Disabled';

            // If this checkbox is a parent toggle, enable/disable its configure button
            const parentSettingDiv = checkbox.closest('.parent-toggle-setting');
            if (parentSettingDiv) {
                const configureBtn = parentSettingDiv.querySelector('.configure-child-btn');
                if (configureBtn) {
                    configureBtn.disabled = !checkbox.checked;
                }
            }
        }
        if (event.target.tagName === 'SELECT') {
            // ... (Unchanged select logic for custom values)
            const select = event.target;
            const customContainer = select.parentElement.querySelector('.custom-input-container');
            if (customContainer) {
                const customInput = customContainer.querySelector('.custom-input');
                if (select.value === 'custom') customContainer.style.display = 'flex';
                else {
                    customContainer.style.display = 'none';
                    if (customInput) customInput.value = '';
                }
            }
        }
    });

     container.addEventListener('input', function(event) {
         if (event.target.type === 'range') {
            // ... (Unchanged slider logic)
            const slider = event.target;
            const sliderContainer = slider.closest('.slider-container');
            if (sliderContainer) {
                 const valueDisplay = sliderContainer.querySelector('.slider-value'); 
                 if (valueDisplay) {
                     let unit = '';
                     if (slider.closest('.setting')) {
                         const label = slider.closest('.setting').querySelector('.setting-label')?.textContent || '';
                         if (label.includes('Temp')) unit = '°C';
                         else if (label.includes('Voltage')) unit = 'mV';
                         else if (label.includes('Level') || label.includes('Battery')) unit = '%';
                     }
                     valueDisplay.textContent = slider.value + unit;
                 }
            }
            return;
         }
     });

    // Initialize configure buttons state based on checkboxes
    container.querySelectorAll('.parent-toggle-setting input[type="checkbox"]').forEach(checkbox => {
        const parentSettingDiv = checkbox.closest('.parent-toggle-setting');
        if (parentSettingDiv) {
            const configureBtn = parentSettingDiv.querySelector('.configure-child-btn');
            if (configureBtn) {
                configureBtn.disabled = !checkbox.checked;
            }
        }
    });
    container.querySelectorAll('.array-field select').forEach(select => select.dispatchEvent(new Event('change', { bubbles: true })));
    container.querySelectorAll('input[type="range"]').forEach(slider => slider.dispatchEvent(new Event('input', { bubbles: true })));

    // Modal event listeners
    document.getElementById('modal-apply-btn').addEventListener('click', applyModalChanges);
    document.getElementById('modal-cancel-btn').addEventListener('click', closeChildSettingsModal);
    document.querySelector('#child-settings-modal .modal-close-btn').addEventListener('click', closeChildSettingsModal);
    document.getElementById('child-settings-modal').addEventListener('click', function(event) {
        if (event.target === this) { // Click on overlay itself
            closeChildSettingsModal();
        }
    });

}

function openChildSettingsModal(parentKey, category, parentLabel) {
    currentModalContext = { parentKey, category, parentLabel };
    const modal = document.getElementById('child-settings-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalBody = document.getElementById('modal-body');

    modalTitle.textContent = `Configure: ${parentLabel || formatLabel(parentKey)}`;
    modalBody.innerHTML = ''; // Clear previous content

    const settingsInCategory = jsonConfig[category];
    if (!settingsInCategory) {
        console.error(`Category ${category} not found in jsonConfig`);
        modalBody.innerHTML = '<p>Error: Configuration data not found for this category.</p>';
        modal.style.display = 'flex';
        return;
    }

    let foundChildren = false;
    for (const childKey in settingsInCategory) {
        if (childKey.startsWith(parentKey) && childKey !== parentKey) {
            const suffix = childKey.substring(parentKey.length);
            if (suffix && (suffix[0] === suffix[0].toUpperCase() || !isNaN(parseInt(suffix[0])) || suffix === 'Value')) {
                foundChildren = true;
                const childValue = settingsInCategory[childKey];
                const childElement = createModalInputElement(childKey, childValue, category);
                if (childElement) {
                    modalBody.appendChild(childElement);
                }
            }
        }
    }
    if (!foundChildren) {
        modalBody.innerHTML = '<p>No configurable child settings found.</p>';
    }
    modal.style.display = 'flex';
}

function createModalInputElement(childKey, childValue, category) {
    const settingDiv = document.createElement('div');
    settingDiv.className = 'setting'; // Re-use .setting for basic structure
    const formattedChildLabel = formatLabel(childKey.substring(currentModalContext.parentKey.length)); // Get label for suffix

    if (typeof childValue === 'boolean') {
        settingDiv.innerHTML = `
            <label class="setting-checkbox">
                <input type="checkbox" data-modal-key="${childKey}" ${childValue ? 'checked' : ''}>
                <span class="checkmark"></span>
                <span class="toggle-label">${formattedChildLabel}</span>
                <span class="toggle-status">${childValue ? 'Enabled' : 'Disabled'}</span>
            </label>
        `;
        // Add change listener for modal toggles' status text
        const modalCheckbox = settingDiv.querySelector('input[type="checkbox"]');
        modalCheckbox.addEventListener('change', function() {
            const statusEl = this.parentElement.querySelector('.toggle-status');
            if (statusEl) statusEl.textContent = this.checked ? 'Enabled' : 'Disabled';
        });

    } else if (typeof childValue === 'number') {
        settingDiv.innerHTML = `
            <label class="setting-label" for="modal-input-${childKey}">${formattedChildLabel}</label>
            <input type="number" id="modal-input-${childKey}" data-modal-key="${childKey}" value="${childValue}">
        `;
    } else { // Default to text
        settingDiv.innerHTML = `
            <label class="setting-label" for="modal-input-${childKey}">${formattedChildLabel}</label>
            <input type="text" id="modal-input-${childKey}" data-modal-key="${childKey}" value="${childValue || ''}">
        `;
    }
    return settingDiv;
}

function applyModalChanges() {
    const { category } = currentModalContext;
    if (!category || !jsonConfig[category]) {
        console.error("Cannot apply modal changes: invalid context or category.");
        closeChildSettingsModal();
        return;
    }

    const modalBody = document.getElementById('modal-body');
    modalBody.querySelectorAll('[data-modal-key]').forEach(inputEl => {
        const childKey = inputEl.dataset.modalKey;
        let newValue;
        if (inputEl.type === 'checkbox') {
            newValue = inputEl.checked;
        } else if (inputEl.type === 'number') {
            newValue = parseFloat(inputEl.value) || 0;
        } else {
            newValue = inputEl.value;
        }
        if (Object.hasOwnProperty.call(jsonConfig[category], childKey)) {
            jsonConfig[category][childKey] = newValue;
        }
    });
    closeChildSettingsModal();
}

function closeChildSettingsModal() {
    const modal = document.getElementById('child-settings-modal');
    modal.style.display = 'none';
    currentModalContext = { parentKey: null, category: null, parentLabel: null };
}


function getUpdatedConfig() {
    // ... (Unchanged)
    const updatedConfigStructured = JSON.parse(JSON.stringify(jsonConfig));
    const processedCustomFields = new Set();

    for (const category in updatedConfigStructured) {
        if (Object.hasOwnProperty.call(updatedConfigStructured, category)) {
            const settings = updatedConfigStructured[category];
            for (const key in settings) {
                if (Object.hasOwnProperty.call(settings, key)) {
                    const dataPath = `${category}.${key}`;

                    if (NON_INTERACTIVE_DIRECTORY_KEYS.includes(key) || key === 'fakeWifiNetworks') {
                        continue;
                    }

                    if (typeof settings[key] === 'object' && settings[key] !== null && !Array.isArray(settings[key])) {
                        // This handles simple objects and SDK-version-like objects.
                        // Child settings modified by the modal are already in jsonConfig,
                        // so they will be correctly part of updatedConfigStructured here.
                        // This part mainly updates non-child object properties if they have UI.
                        const objectKeys = Object.keys(settings[key]);
                        const newObject = {};
                        let objectUpdated = false;
                        objectKeys.forEach(objKey => {
                            // Only update from DOM if it's NOT a child setting that was handled by modal
                            // This check is a bit indirect. Better to rely on jsonConfig being authoritative for modal-edited children.
                            // For non-boolean parent objects, their fields are directly on the page.
                            const objElement = document.querySelector(`[data-path="${dataPath}.${objKey}"]`);
                            if (objElement) { // Element exists on main page
                                let value;
                                if (objElement.type === 'checkbox') value = objElement.checked;
                                else if (objElement.type === 'number' || objElement.type === 'range') value = parseFloat(objElement.value) || 0;
                                else value = objElement.value;
                                newObject[objKey] = value;
                                objectUpdated = true;
                            } else { // No direct UI element, so take from (potentially modal-updated) jsonConfig
                                newObject[objKey] = settings[key][objKey];
                            }
                        });
                         updatedConfigStructured[category][key] = newObject; // Always assign, as children might have changed via modal
                        continue;
                    }

                    const element = document.querySelector(`[data-path="${dataPath}"][data-key="${key}"]`);
                    if (!element) {
                        // This could be a boolean parent whose children were edited in modal.
                        // The parent's own boolean value is still read from its checkbox.
                        const checkboxElement = document.querySelector(`input[type="checkbox"][data-path="${dataPath}"][data-key="${key}"]`);
                        if (checkboxElement) {
                            updatedConfigStructured[category][key] = checkboxElement.checked;
                        }
                        // If it's neither a direct element nor a known checkbox, it's likely a child handled by modal
                        // or a non-interactive key, already correctly in updatedConfigStructured from jsonConfig.
                        continue;
                    }

                    let value;
                    if (element.type === 'checkbox') {
                        value = element.checked;
                    } else if (element.type === 'number' || element.type === 'range') {
                        value = parseFloat(element.value) || 0;
                    } else if (element.tagName === 'SELECT') {
                        if (element.value === 'custom') {
                            const customInput = document.querySelector(`input[data-path="${dataPath}"][data-key="${key}-custom"]`);
                            if (customInput) {
                                updatedConfigStructured[category][key] = "CUSTOM";
                                let customPropertyName;
                                if (key.startsWith('change')) {
                                    let baseProperty = key.substring(6);
                                    if (baseProperty.endsWith('ID')) baseProperty = baseProperty.substring(0, baseProperty.length - 2) + 'Id';
                                    else if (baseProperty.endsWith('Mac')) baseProperty = baseProperty.substring(0, baseProperty.length - 3) + 'MAC';
                                    baseProperty = baseProperty.charAt(0).toLowerCase() + baseProperty.slice(1);
                                    customPropertyName = 'custom' + baseProperty.charAt(0).toUpperCase() + baseProperty.slice(1);
                                } else {
                                    customPropertyName = 'custom' + key.charAt(0).toUpperCase() + key.slice(1);
                                }
                                updatedConfigStructured[category][customPropertyName] = customInput.value;
                                processedCustomFields.add(key);
                                continue;
                            } else {
                                value = "CUSTOM";
                            }
                        } else {
                            value = element.value;
                            let customPropertyName;
                            if (key.startsWith('change')) {
                                let baseProperty = key.substring(6);
                                if (baseProperty.endsWith('ID')) baseProperty = baseProperty.substring(0, baseProperty.length - 2) + 'Id';
                                else if (baseProperty.endsWith('Mac')) baseProperty = baseProperty.substring(0, baseProperty.length - 3) + 'MAC';
                                baseProperty = baseProperty.charAt(0).toLowerCase() + baseProperty.slice(1);
                                customPropertyName = 'custom' + baseProperty.charAt(0).toUpperCase() + baseProperty.slice(1);
                            } else {
                                customPropertyName = 'custom' + key.charAt(0).toUpperCase() + key.slice(1);
                            }
                            if (updatedConfigStructured[category] && Object.hasOwnProperty.call(updatedConfigStructured[category], customPropertyName)) {
                                delete updatedConfigStructured[category][customPropertyName];
                            }
                        }
                    } else {
                        value = element.value;
                    }

                    if (!processedCustomFields.has(key)) {
                        updatedConfigStructured[category][key] = value;
                    }
                }
            }
        }
    }

    const flatConfig = {};
    for (const category in updatedConfigStructured) {
        if (Object.hasOwnProperty.call(updatedConfigStructured, category)) {
            const settingsInCategory = updatedConfigStructured[category];
            for (const key in settingsInCategory) {
                if (Object.hasOwnProperty.call(settingsInCategory, key)) {
                    flatConfig[key] = settingsInCategory[key];
                }
            }
        }
    }
    return flatConfig;
}


function saveConfig() {
    // ... (Unchanged)
    let packageName = currentPackageName;
    if (!packageName) {
        packageName = prompt("Package name not detected. Please enter the package name to encrypt the configuration:");
        if (!packageName || packageName.trim() === '') {
            alert("Package name is required to encrypt and save the configuration.");
            if(window.Android) window.Android.showToast("Save cancelled: Package name required.");
            return;
        }
        updatePackageName(packageName);
    }

    const finalFlatConfig = getUpdatedConfig();
    const jsonString = JSON.stringify(finalFlatConfig, null, 2);

    if (window.Android) {
        try {
            window.Android.saveEncryptedConfig(jsonString, packageName, configFileSplitCount);
            window.Android.showToast("Configuration saved successfully!");
        } catch (e) {
            console.error("Error calling Android.saveEncryptedConfig:", e);
            const errorMessage = `Error saving config: ${e.message}`;
            window.Android.showToast(errorMessage);
            alert(`Error saving config via Android interface: ${e.message}\n\nPlease check Android Studio Logcat for details.`);
        }
    } else {
        console.warn("Running in browser mode. Configuration will be downloaded as plain text JSON.");
        const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${packageName}_cloneSettings.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        alert("Running in browser mode. Configuration downloaded as JSON file (not encrypted).");
    }
}

</script>
</body>
</html>